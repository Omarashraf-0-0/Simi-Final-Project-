// ignore_for_file: prefer_const_constructors
import 'dart:convert'; // Added for jsonEncode
import 'package:flutter/material.dart';
import 'package:timezone/data/latest_all.dart' as tz;
import 'package:flutter_downloader/flutter_downloader.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'firebase_options.dart'; // This file is generated by FlutterFire CLI
import 'package:studymate/theme/theme.dart';
import 'package:studymate/theme/theme_manager.dart';
import 'package:studymate/pages/Notifications/NotificationClass.dart';
import 'package:studymate/pages/Notifications/InAppMessagingNotification.dart';
import 'package:studymate/services/enhanced_notification_service.dart';
import 'package:studymate/services/schedule_notification_sync.dart';
import 'package:studymate/router/app_router.dart';
import 'package:go_router/go_router.dart';

Future<void> firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // await Firebase.initializeApp();
  print('Handling background message ${message.messageId}');
  // Navigation will be handled when app is opened
}

ThemeManager themeManager = ThemeManager();

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Hive
  await Hive.initFlutter();
  await Hive.openBox('userBox');

  // Initialize Flutter Downloader
  await FlutterDownloader.initialize(
    debug: true,
  );

  // Initialize Firebase (only once)
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Initialize timezone data
  tz.initializeTimeZones();

  // Initialize NotificationService (old)
  await NotificationService().init();

  // Initialize Enhanced Notification Service (new comprehensive system)
  await EnhancedNotificationService().initialize();

  // Initialize MessagingService
  await MessagingService.initialize((payload) {
    print("User tapped notification with payload: $payload");
    // Navigation will be handled in _MyAppState
  });

  // Sync all schedule, quiz, and assignment notifications
  final scheduleSync = ScheduleNotificationSync();
  await scheduleSync.syncAllNotifications();

  // Setup background message handler
  FirebaseMessaging.onBackgroundMessage(firebaseMessagingBackgroundHandler);

  runApp(MyApp());
}

// Helper function to handle notification navigation
void handleNotificationNavigation(Map<String, dynamic> data) {
  final context = rootNavigatorKey.currentContext;
  if (context == null) return;

  final type = data['type'];
  switch (type) {
    case 'schedule':
      context.go(AppRoutes.schedule);
      break;
    case 'rank':
      context.go(AppRoutes.profile);
      break;
    case 'quiz':
      context.go(AppRoutes.quiz);
      break;
    case 'assignment':
      context.go(AppRoutes.resources);
      break;
    case 'notification_settings':
      context.go(AppRoutes.notificationSettings);
      break;
    default:
      context.go(AppRoutes.home);
  }
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});
  @override
  _MyAppState createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  @override
  void initState() {
    super.initState();
    themeManager.addListener(themeListner);
    _setupMessagingListeners();
  }

  void _setupMessagingListeners() {
    MessagingService.onMessage.listen(MessagingService.invokeLocalNotification);
    MessagingService.onMessageOpenedApp.listen((RemoteMessage message) {
      print('Notification opened: ${message.data}');
      // Handle navigation using go_router
      if (message.data.isNotEmpty) {
        handleNotificationNavigation(message.data);
      }
    });
    
    // Handle notification tap from terminated state
    FirebaseMessaging.instance.getInitialMessage().then((RemoteMessage? message) {
      if (message != null && message.data.isNotEmpty) {
        // Delay navigation to ensure app is fully initialized
        Future.delayed(const Duration(milliseconds: 500), () {
          handleNotificationNavigation(message.data);
        });
      }
    });
  }

  @override
  void dispose() {
    themeManager.removeListener(themeListner);
    super.dispose();
  }

  void themeListner() {
    if (mounted) {
      setState(() {});
    }
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerConfig: appRouter,
      themeMode: themeManager.themeData,
      theme: TAppTheme.lightTheme,
      darkTheme: TAppTheme.darkTheme,
      debugShowCheckedModeBanner: false,
    );
  }
}
// // دالة لتهيئة النوتيفيكيشن
// Future<void> _initializeNotifications() async {
//   // إعدادات Android
//   const AndroidInitializationSettings initializationSettingsAndroid =
//       AndroidInitializationSettings('@mipmap/ic_launcher');

//   // إعدادات iOS
//   final DarwinInitializationSettings initializationSettingsIOS =
//       DarwinInitializationSettings(
//     requestAlertPermission: true,
//     requestBadgePermission: true,
//     requestSoundPermission: true,
//   );

//   // دمج الإعدادات
//   final InitializationSettings initializationSettings = InitializationSettings(
//     android: initializationSettingsAndroid,
//     iOS: initializationSettingsIOS,
//   );

//   // تهيئة الـ FlutterLocalNotificationsPlugin
//   await flutterLocalNotificationsPlugin.initialize(
//     initializationSettings,
//     onDidReceiveNotificationResponse:
//         (NotificationResponse notificationResponse) async {
//       // التعامل مع النوتيفيكيشن عند الضغط عليها
//       if (notificationResponse.payload != null) {
//         // navigatorKey.currentState?.push(
//           // MaterialPageRoute(builder: (context) => NotificationPage(notifications: [],)),
//         // );
//       }
//     },
//   );
// }

// Future<void> rrequestPermission() async {
//   FirebaseMessaging messaging = FirebaseMessaging.instance;

//   NotificationSettings settings = await messaging.requestPermission(
//     alert: true,
//     badge: true,
//     sound: true,
//     provisional: false,
//   );

//   if (settings.authorizationStatus == AuthorizationStatus.authorized) {
//     print('User granted permission');
//   } else if (settings.authorizationStatus == AuthorizationStatus.provisional) {
//     print('User granted provisional permission');
//   } else {
//     print('User declined or has not accepted permission');
//   }
// }

// Future<void> _requestPermissions() async {
//   if (Platform.isAndroid) {
//     if (await Permission.notification.request().isGranted) {
//       print('Notification permission granted');
//     } else {
//       print('Notification permission denied');
//     }
//   } else if (Platform.isIOS) {
//     final iosImplementation = flutterLocalNotificationsPlugin
//         .resolvePlatformSpecificImplementation<
//             IOSFlutterLocalNotificationsPlugin>();
//     if (iosImplementation != null) {
//       final granted = await iosImplementation.requestPermissions(
//         alert: true,
//         badge: true,
//         sound: true,
//       );
//       if (granted != null) {
//         // الإذن ممنوح
//         print('Notification permission granted');
//       } else {
//         // الإذن مرفوض
//         print('Notification permission denied');
//       }
//     }
//   }
// }
// دوال لإظهار وجدولة النوتيفيكيشن

// Future<void> showNotification(String title, String info) async {
//   const AndroidNotificationDetails androidPlatformChannelSpecifics =
//       AndroidNotificationDetails(
//     'your_channel_id', // معرّف القناة
//     'Your Channel Name', // اسم القناة
//     channelDescription: 'Your channel description',
//     importance: Importance.max,
//     priority: Priority.high,
//     ticker: 'ticker',
//   );

//   const NotificationDetails platformChannelSpecifics = NotificationDetails(
//     android: androidPlatformChannelSpecifics,
//   );

//   await flutterLocalNotificationsPlugin.show(
//     0, // رقم تعريف النوتيفيكيشن
//     title,
//     info,
//     platformChannelSpecifics,
//     payload: 'What is this?',
//   );
// }


// Future<void> scheduleNotification({
//   required String title,
//   required String body,
//   required DateTime scheduledDate,
// }) async {
//   // Convert DateTime to TZDateTime for timezone compatibility
//   final tz.TZDateTime tzScheduledDate = tz.TZDateTime.from(scheduledDate, tz.local);

//   await flutterLocalNotificationsPlugin.zonedSchedule(
//     scheduledDate.millisecondsSinceEpoch ~/ 1000, // Unique notification ID
//     title, // Notification title
//     body,  // Notification body
//     tzScheduledDate, // Time to show the notification
//     const NotificationDetails(
//       android: AndroidNotificationDetails(
//         '1', // Replace with your channel ID
//         'Your Channel Name', // Replace with your channel name
//         channelDescription: 'Your channel description', // Optional description
//         importance: Importance.max, // High visibility
//         priority: Priority.high, // High priority
//       ),
//     ),
//     androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
//     uiLocalNotificationDateInterpretation:
//         UILocalNotificationDateInterpretation.absoluteTime,
//   );

//   print('Notification scheduled for: $tzScheduledDate');
// }